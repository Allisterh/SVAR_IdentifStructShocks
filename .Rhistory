est.VAR <- cholesky.res$est.VAR
Phi     <- Acoef(est.VAR)
B.hat <- cholesky.res$B.hat
cst     <- Bcoef(est.VAR)[,p*n+1]
resids  <- residuals(est.VAR)
Omega   <- var(resids)
# if no bootstrap then simply use point estimate
simulated.IRFs  <- replicate(1,IRFs, simplify="array")
simulated.B.hat <- replicate(1,B.hat, simplify="array")
simulated.Phi   <- replicate(1,Phi, simplify="array")
# if bootstrap then generate and store simulated IRFs, B.hat and Phi
if(bootstrap.replications>1){
bootstrap.res <- param.bootstrap(y,p,nb.periods.IRF,n,
bootstrap.replications,
posit.of.shock = 0)
simulated.IRFs  <- bootstrap.res$simulated.IRFs
simulated.B.hat <- bootstrap.res$simulated.B.hat
simulated.Phi   <- bootstrap.res$simulated.Phi
}
# Initialize Q as identity matrix
Q <- replicate(bootstrap.replications,diag(n), simplify="array")
# This is where we will store the IRFs
IRFs.final <- array(NaN,c(n,n,nb.periods.IRF,bootstrap.replications))
# This loop identifies the relevant Q for each bootstrap replication
for (l in 1:bootstrap.replications){
##############################
# Identification of main GDP shock
##############################
# Compute S
WWW <- array(0,c(n,n))
for (h in 1:H){
V99 <- simulated.IRFs[,,h,l]
JJ <- (H+1-h)*t(V99)%*%En%*%V99
WWW <- WWW+JJ
}
r <- eigen(WWW)
# Take the eigenvector with the highest eigenvalue
eigvec <- matrix(r$vectors[,1],n,1)
# We might need to adjust the sign
if (sum(simulated.IRFs[1,,,l]%*%eigvec)>0){
Q[,1,l] <- Q[,,l]%*%eigvec
}else{
Q[,1,l] <- - Q[,,l]%*%eigvec
}
Q[,2:n,l] <- Null(Q[,1,l]) # we ensure that columns 2 to n are orthogonal to the first
# New IRFs
for (t in 1:nb.periods.IRF){
IRFs.final[,,t,l] <- simulated.IRFs[,,t,l]%*%Q[,,l]
}
}
nb.periods.IRF <- 40
p <- 2
bootstrap.replications <- 100
confidence.interval <- 0.75
indic.plot <- 1
nb.shocks <- 3
names.of.shocks <- c("TFP surprise","TFP news","Sentiment")
Hn <- 40 #horizon for news shock
Hs <- 2 #horizon for sentiment shock
# ===============================
# FEVM + zeros
# ===============================
En <- array(0,c(n,n))
En[1,1] <- 1
Es <- array(0,c(n,n))
Es[3,3] <- 1
# Initialize Q as identity matrix
Q <- replicate(bootstrap.replications,diag(n), simplify="array")
# This loop identifies the relevant Q for each bootstrap replication
for (l in 1:bootstrap.replications){
##############################
# Identification of news shocks
##############################
# Compute S
WWW <- array(0,c(n-1,n-1))
for (h in 1:Hn){
V99 <- simulated.IRFs[,,h,l]%*%Q[,2:n,l]
# Notice that we use only columns 2 to n of Q: the first column selects the TFP surprise shock,
# which is the first shock in the Cholesky decomposition where TFP is ordered first
JJ <- (Hn+1-h)*t(V99)%*%En%*%V99
WWW <- WWW+JJ
}
r <- eigen(WWW)
# Take the eigenvector with the highest eigenvalue
eigvec <- matrix(r$vectors[,1],n-1,1)
# We might need to adjust the sign
if (simulated.IRFs[1,,20,l]%*%Q[,2:n,l]%*%eigvec>0){
Q[,2,l] <- Q[,2:n,l]%*%eigvec
}else{
Q[,2,l] <- - Q[,2:n,l]%*%eigvec
}
Q[,3:n,l] <- Null(Q[,1:2,l]) # we ensure that columns 3 to n are orthogonal to the first 2
#####################################
# Identification of sentiment shocks
#####################################
# Compute S
WWW <- array(0,c(n-2,n-2))
for (h in 1:Hs){
V99 <- simulated.IRFs[,,h,l]%*%Q[,3:n,l]
# Notice that we use only columns 3 to n of Q: the first column selects the TFP surprise shock,
# which is the first shock in the Cholesky decomposition where TFP is ordered first, the second column generates
# the linear combination of "Cholesky shocks" that is orthogonal to TFP surprise and best explains TFP up to
# horizon 40 (see last step)
JJ <- (Hs+1-h)*t(V99)%*%Es%*%V99
WWW <- WWW+JJ
}
r <- eigen(WWW)
# Take the eigenvector with the highest eigenvalue
eigvec <- matrix(r$vectors[,1],n-2,1)
# We might need to adjust the sign
if (simulated.IRFs[3,,2,l]%*%Q[,3:n,l]%*%eigvec>0){
Q[,3,l] <- Q[,3:n,l]%*%eigvec
}else{
Q[,3,l] <- -Q[,3:n,l]%*%eigvec
}
Q[,4:n,l] <- Null(Q[,1:3,l]) # we ensure that columns 4 to n are orthogonal to the first 3
for (t in 1:nb.periods.IRF){
IRFs.final[,,t,l] <- simulated.IRFs[,,t,l]%*%Q[,,l]
}
}
# compute some key moments of the simulated IRFs
stdv.IRFs <- apply(IRFs.final,c(1,2,3),sd)
CI.lower.bounds <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,(1-confidence.interval)/2)})
confidence.interval
library(IdSS)
library(readxl)
library(vars)
library(Matrix)
# Declare data:
TFP   <- levpan$tfp_lev
GDP   <- levpan$lngdpcap
E12   <- levpan$e12m
CONS  <- levpan$lnconcap
HOURS <- levpan$lnhrscap
y <- cbind(TFP,GDP,E12,CONS,HOURS)
names.of.variables <- c("TFP","GDP","E12","Consumption","Hours")
colnames(y)  <- names.of.variables
T <- dim(y)[1]
n <- dim(y)[2]
p <- 2
nb.periods.IRF <- 40
bootstrap.replications <- 1000
confidence.interval <- 0.75
indic.plot <- 1
H <- 20
# ===============================
# FEVM
# ===============================
y0.star <- rep(0,n*p)
En <- array(0,c(n,n))
En[2,2] <- 1
stdv.IRFs <- list()
# do Choleski (we need the FULL IRFs)
cholesky.res <- svar.ordering.all(y,p,nb.periods.IRF,n)
# Store results
IRFs <- cholesky.res$IRFs
est.VAR <- cholesky.res$est.VAR
Phi     <- Acoef(est.VAR)
B.hat <- cholesky.res$B.hat
cst     <- Bcoef(est.VAR)[,p*n+1]
resids  <- residuals(est.VAR)
Omega   <- var(resids)
# if no bootstrap then simply use point estimate
simulated.IRFs  <- replicate(1,IRFs, simplify="array")
simulated.B.hat <- replicate(1,B.hat, simplify="array")
simulated.Phi   <- replicate(1,Phi, simplify="array")
# if bootstrap then generate and store simulated IRFs, B.hat and Phi
if(bootstrap.replications>1){
bootstrap.res <- param.bootstrap(y,p,nb.periods.IRF,n,
bootstrap.replications,
posit.of.shock = 0)
simulated.IRFs  <- bootstrap.res$simulated.IRFs
simulated.B.hat <- bootstrap.res$simulated.B.hat
simulated.Phi   <- bootstrap.res$simulated.Phi
}
# Initialize Q as identity matrix
Q <- replicate(bootstrap.replications,diag(n), simplify="array")
# This is where we will store the IRFs
IRFs.final <- array(NaN,c(n,n,nb.periods.IRF,bootstrap.replications))
# This loop identifies the relevant Q for each bootstrap replication
for (l in 1:bootstrap.replications){
##############################
# Identification of main GDP shock
##############################
# Compute S
WWW <- array(0,c(n,n))
for (h in 1:H){
V99 <- simulated.IRFs[,,h,l]
JJ <- (H+1-h)*t(V99)%*%En%*%V99
WWW <- WWW+JJ
}
r <- eigen(WWW)
# Take the eigenvector with the highest eigenvalue
eigvec <- matrix(r$vectors[,1],n,1)
# We might need to adjust the sign
if (sum(simulated.IRFs[1,,,l]%*%eigvec)>0){
Q[,1,l] <- Q[,,l]%*%eigvec
}else{
Q[,1,l] <- - Q[,,l]%*%eigvec
}
Q[,2:n,l] <- Null(Q[,1,l]) # we ensure that columns 2 to n are orthogonal to the first
# New IRFs
for (t in 1:nb.periods.IRF){
IRFs.final[,,t,l] <- simulated.IRFs[,,t,l]%*%Q[,,l]
}
}
library(IdSS)
library(readxl)
library(vars)
library(Matrix)
# Declare data:
TFP   <- levpan$tfp_lev
GDP   <- levpan$lngdpcap
E12   <- levpan$e12m
CONS  <- levpan$lnconcap
HOURS <- levpan$lnhrscap
y <- cbind(TFP,GDP,E12,CONS,HOURS)
names.of.variables <- c("TFP","GDP","E12","Consumption","Hours")
colnames(y)  <- names.of.variables
T <- dim(y)[1]
n <- dim(y)[2]
p <- 2
nb.periods.IRF <- 40
bootstrap.replications <- 1000
confidence.interval <- 0.75
indic.plot <- 1
H <- 20
# ===============================
# FEVM
# ===============================
y0.star <- rep(0,n*p)
En <- array(0,c(n,n))
En[2,2] <- 1
stdv.IRFs <- list()
# do Choleski (we need the FULL IRFs)
cholesky.res <- svar.ordering.all(y,p,nb.periods.IRF,n)
# Store results
IRFs <- cholesky.res$IRFs
est.VAR <- cholesky.res$est.VAR
Phi     <- Acoef(est.VAR)
B.hat <- cholesky.res$B.hat
cst     <- Bcoef(est.VAR)[,p*n+1]
resids  <- residuals(est.VAR)
Omega   <- var(resids)
# if no bootstrap then simply use point estimate
simulated.IRFs  <- replicate(1,IRFs, simplify="array")
simulated.B.hat <- replicate(1,B.hat, simplify="array")
simulated.Phi   <- replicate(1,Phi, simplify="array")
# if bootstrap then generate and store simulated IRFs, B.hat and Phi
if(bootstrap.replications>1){
bootstrap.res <- param.bootstrap(y,p,nb.periods.IRF,n,
bootstrap.replications,
posit.of.shock = 0)
simulated.IRFs  <- bootstrap.res$simulated.IRFs
simulated.B.hat <- bootstrap.res$simulated.B.hat
simulated.Phi   <- bootstrap.res$simulated.Phi
}
# Initialize Q as identity matrix
Q <- replicate(bootstrap.replications,diag(n), simplify="array")
# This is where we will store the IRFs
IRFs.final <- array(NaN,c(n,n,nb.periods.IRF,bootstrap.replications))
# This loop identifies the relevant Q for each bootstrap replication
for (l in 1:bootstrap.replications){
##############################
# Identification of main GDP shock
##############################
# Compute S
WWW <- array(0,c(n,n))
for (h in 1:H){
V99 <- simulated.IRFs[,,h,l]
JJ <- (H+1-h)*t(V99)%*%En%*%V99
WWW <- WWW+JJ
}
r <- eigen(WWW)
# Take the eigenvector with the highest eigenvalue
eigvec <- matrix(r$vectors[,1],n,1)
# We might need to adjust the sign
if (simulated.IRFs[1,,20,l]%*%eigvec>0){
Q[,1,l] <- Q[,,l]%*%eigvec
}else{
Q[,1,l] <- - Q[,,l]%*%eigvec
}
Q[,2:n,l] <- Null(Q[,1,l]) # we ensure that columns 2 to n are orthogonal to the first
# New IRFs
for (t in 1:nb.periods.IRF){
IRFs.final[,,t,l] <- simulated.IRFs[,,t,l]%*%Q[,,l]
}
}
# compute some key moments of the simulated IRFs
stdv.IRFs <- apply(IRFs.final,c(1,2,3),sd)
CI.lower.bounds <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,(1-confidence.interval)/2)})
CI.upper.bounds <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,1-(1-confidence.interval)/2)})
CI.median <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,0.5)})
# Plot graphs
par(mfrow=c(2,ifelse(round(n/2)==n/2,n/2,(n+1)/2)))
for(i in 1:n){
plot(CI.median[i,1,],type="l",lwd=2,xlab="",ylab="",
ylim=c(min(CI.lower.bounds[i,1,]),
max(CI.upper.bounds[i,1,])),
main=paste("Effect of Main GDP shock on ",names.of.variables[i],sep=""))
abline(h=0,col="grey")
lines(CI.lower.bounds[i,1,],col="red",lty=2,lwd=2)
lines(CI.upper.bounds[i,1,],col="red",lty=2,lwd=2)
}
source("various_proc_TS.R")
variance.decomp <- variance.decomp(IRFs.final)
vardecomp <- variance.decomp$vardecomp
mean(vardecomp[2,2,40,,1])
nb.periods.IRF <- 40
p <- 2
bootstrap.replications <- 100
confidence.interval <- 0.75
indic.plot <- 1
nb.shocks <- 3
names.of.shocks <- c("TFP surprise","TFP news","Sentiment")
Hn <- 40 #horizon for news shock
Hs <- 2 #horizon for sentiment shock
# ===============================
# FEVM + zeros
# ===============================
En <- array(0,c(n,n))
En[1,1] <- 1
Es <- array(0,c(n,n))
Es[3,3] <- 1
# Initialize Q as identity matrix
Q <- replicate(bootstrap.replications,diag(n), simplify="array")
# This loop identifies the relevant Q for each bootstrap replication
for (l in 1:bootstrap.replications){
##############################
# Identification of news shocks
##############################
# Compute S
WWW <- array(0,c(n-1,n-1))
for (h in 1:Hn){
V99 <- simulated.IRFs[,,h,l]%*%Q[,2:n,l]
# Notice that we use only columns 2 to n of Q: the first column selects the TFP surprise shock,
# which is the first shock in the Cholesky decomposition where TFP is ordered first
JJ <- (Hn+1-h)*t(V99)%*%En%*%V99
WWW <- WWW+JJ
}
r <- eigen(WWW)
# Take the eigenvector with the highest eigenvalue
eigvec <- matrix(r$vectors[,1],n-1,1)
# We might need to adjust the sign
if (simulated.IRFs[1,,20,l]%*%Q[,2:n,l]%*%eigvec>0){
Q[,2,l] <- Q[,2:n,l]%*%eigvec
}else{
Q[,2,l] <- - Q[,2:n,l]%*%eigvec
}
Q[,3:n,l] <- Null(Q[,1:2,l]) # we ensure that columns 3 to n are orthogonal to the first 2
#####################################
# Identification of sentiment shocks
#####################################
# Compute S
WWW <- array(0,c(n-2,n-2))
for (h in 1:Hs){
V99 <- simulated.IRFs[,,h,l]%*%Q[,3:n,l]
# Notice that we use only columns 3 to n of Q: the first column selects the TFP surprise shock,
# which is the first shock in the Cholesky decomposition where TFP is ordered first, the second column generates
# the linear combination of "Cholesky shocks" that is orthogonal to TFP surprise and best explains TFP up to
# horizon 40 (see last step)
JJ <- (Hs+1-h)*t(V99)%*%Es%*%V99
WWW <- WWW+JJ
}
r <- eigen(WWW)
# Take the eigenvector with the highest eigenvalue
eigvec <- matrix(r$vectors[,1],n-2,1)
# We might need to adjust the sign
if (simulated.IRFs[3,,2,l]%*%Q[,3:n,l]%*%eigvec>0){
Q[,3,l] <- Q[,3:n,l]%*%eigvec
}else{
Q[,3,l] <- -Q[,3:n,l]%*%eigvec
}
Q[,4:n,l] <- Null(Q[,1:3,l]) # we ensure that columns 4 to n are orthogonal to the first 3
for (t in 1:nb.periods.IRF){
IRFs.final[,,t,l] <- simulated.IRFs[,,t,l]%*%Q[,,l]
}
}
# compute some key moments of the simulated IRFs
stdv.IRFs <- apply(IRFs.final,c(1,2,3),sd)
CI.lower.bounds <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,(1-confidence.interval)/2)})
CI.upper.bounds <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,1-(1-confidence.interval)/2)})
CI.median <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,0.5)})
# Plot graphs
for (j in 1:nb.shocks){
par(mfrow=c(2,ifelse(round(n/2)==n/2,n/2,(n+1)/2)))
for(i in 1:n){
plot(CI.median[i,j,],type="l",lwd=2,xlab="",ylab="",
ylim=c(min(CI.lower.bounds[i,j,]),
max(CI.upper.bounds[i,j,])),
main=paste("Effect of ",names.of.shocks[j]," on ",names.of.variables[i],sep=""))
abline(h=0,col="grey")
lines(CI.lower.bounds[i,j,],col="red",lty=2,lwd=2)
lines(CI.upper.bounds[i,j,],col="red",lty=2,lwd=2)
}
}
nb.periods.IRF <- 40
p <- 2
bootstrap.replications <- 1000
confidence.interval <- 0.75
indic.plot <- 1
nb.shocks <- 3
names.of.shocks <- c("TFP surprise","TFP news","Sentiment")
Hn <- 40 #horizon for news shock
Hs <- 2 #horizon for sentiment shock
# ===============================
# FEVM + zeros
# ===============================
En <- array(0,c(n,n))
En[1,1] <- 1
Es <- array(0,c(n,n))
Es[3,3] <- 1
# Initialize Q as identity matrix
Q <- replicate(bootstrap.replications,diag(n), simplify="array")
# This loop identifies the relevant Q for each bootstrap replication
for (l in 1:bootstrap.replications){
##############################
# Identification of news shocks
##############################
# Compute S
WWW <- array(0,c(n-1,n-1))
for (h in 1:Hn){
V99 <- simulated.IRFs[,,h,l]%*%Q[,2:n,l]
# Notice that we use only columns 2 to n of Q: the first column selects the TFP surprise shock,
# which is the first shock in the Cholesky decomposition where TFP is ordered first
JJ <- (Hn+1-h)*t(V99)%*%En%*%V99
WWW <- WWW+JJ
}
r <- eigen(WWW)
# Take the eigenvector with the highest eigenvalue
eigvec <- matrix(r$vectors[,1],n-1,1)
# We might need to adjust the sign
if (simulated.IRFs[1,,20,l]%*%Q[,2:n,l]%*%eigvec>0){
Q[,2,l] <- Q[,2:n,l]%*%eigvec
}else{
Q[,2,l] <- - Q[,2:n,l]%*%eigvec
}
Q[,3:n,l] <- Null(Q[,1:2,l]) # we ensure that columns 3 to n are orthogonal to the first 2
#####################################
# Identification of sentiment shocks
#####################################
# Compute S
WWW <- array(0,c(n-2,n-2))
for (h in 1:Hs){
V99 <- simulated.IRFs[,,h,l]%*%Q[,3:n,l]
# Notice that we use only columns 3 to n of Q: the first column selects the TFP surprise shock,
# which is the first shock in the Cholesky decomposition where TFP is ordered first, the second column generates
# the linear combination of "Cholesky shocks" that is orthogonal to TFP surprise and best explains TFP up to
# horizon 40 (see last step)
JJ <- (Hs+1-h)*t(V99)%*%Es%*%V99
WWW <- WWW+JJ
}
r <- eigen(WWW)
# Take the eigenvector with the highest eigenvalue
eigvec <- matrix(r$vectors[,1],n-2,1)
# We might need to adjust the sign
if (simulated.IRFs[3,,2,l]%*%Q[,3:n,l]%*%eigvec>0){
Q[,3,l] <- Q[,3:n,l]%*%eigvec
}else{
Q[,3,l] <- -Q[,3:n,l]%*%eigvec
}
Q[,4:n,l] <- Null(Q[,1:3,l]) # we ensure that columns 4 to n are orthogonal to the first 3
for (t in 1:nb.periods.IRF){
IRFs.final[,,t,l] <- simulated.IRFs[,,t,l]%*%Q[,,l]
}
}
# compute some key moments of the simulated IRFs
stdv.IRFs <- apply(IRFs.final,c(1,2,3),sd)
CI.lower.bounds <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,(1-confidence.interval)/2)})
CI.upper.bounds <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,1-(1-confidence.interval)/2)})
CI.median <- apply(IRFs.final,c(1,2,3),
function(x){quantile(x,0.5)})
# Plot graphs
for (j in 1:nb.shocks){
par(mfrow=c(2,ifelse(round(n/2)==n/2,n/2,(n+1)/2)))
for(i in 1:n){
plot(CI.median[i,j,],type="l",lwd=2,xlab="",ylab="",
ylim=c(min(CI.lower.bounds[i,j,]),
max(CI.upper.bounds[i,j,])),
main=paste("Effect of ",names.of.shocks[j]," on ",names.of.variables[i],sep=""))
abline(h=0,col="grey")
lines(CI.lower.bounds[i,j,],col="red",lty=2,lwd=2)
lines(CI.upper.bounds[i,j,],col="red",lty=2,lwd=2)
}
}
source("various_proc_TS.R")
variance.decomp <- variance.decomp(IRFs.final)
vardecomp <- variance.decomp$vardecomp
mean(vardecomp[2,2,40,,1])
mean(vardecomp[2,2,40,,2])
mean(vardecomp[2,2,40,,3])
mean(vardecomp[2,2,40,,1])
mean(vardecomp[2,2,40,,2])
mean(vardecomp[2,2,40,,3])
mean(vardecomp[2,2,5,,1])
mean(vardecomp[2,2,5,,2])
mean(vardecomp[2,2,5,,3])
mean(vardecomp[2,2,1,,1])
mean(vardecomp[2,2,1,,2])
mean(vardecomp[2,2,1,,3])
library(devtools)
install_github("jrenne/IdSS")
library(IdSS)
